---
description: 자연어 기능 설명으로부터 기능 명세를 생성하거나 업데이트합니다.
handoffs:
  - label: 기술 계획 작성
    agent: speckit.plan
    prompt: 명세에 대한 계획을 생성합니다. 다음으로 구축하고 있습니다...
  - label: 명세 요구사항 명확화
    agent: speckit.clarify
    prompt: 명세 요구사항을 명확히 합니다
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 사용자 입력

```text
$ARGUMENTS
```

진행하기 전에 사용자 입력을 **반드시** 고려해야 합니다(비어있지 않은 경우).

## 개요

트리거 메시지에서 사용자가 `/speckit.specify` 다음에 입력한 텍스트가 **바로** 기능 설명입니다. 아래에 `{ARGS}`가 문자 그대로 나타나더라도 이 대화에서 항상 사용할 수 있다고 가정하십시오. 사용자가 빈 명령을 제공하지 않은 한 반복하도록 요청하지 마십시오.

주어진 기능 설명으로 다음을 수행합니다:

1. **브랜치를 위한 간결한 짧은 이름** (2-4 단어) 생성:
   - 기능 설명을 분석하고 가장 의미 있는 키워드를 추출합니다
   - 기능의 본질을 포착하는 2-4 단어 짧은 이름을 생성합니다
   - 가능한 경우 동작-명사 형식 사용 (예: "add-user-auth", "fix-payment-bug")
   - 기술 용어 및 약어 보존 (OAuth2, API, JWT 등)
   - 간결하게 유지하되 한눈에 기능을 이해할 수 있을 만큼 설명적이어야 합니다
   - 예시:
     - "사용자 인증을 추가하고 싶습니다" → "user-auth"
     - "API용 OAuth2 통합 구현" → "oauth2-api-integration"
     - "분석을 위한 대시보드 생성" → "analytics-dashboard"
     - "결제 처리 타임아웃 버그 수정" → "fix-payment-timeout"

2. **새 브랜치를 생성하기 전에 기존 브랜치 확인**:

   a. 먼저, 최신 정보를 확보하기 위해 모든 원격 브랜치를 가져옵니다:
      ```bash
      git fetch --all --prune
      ```

   b. short-name에 대해 모든 소스에서 가장 높은 기능 번호를 찾습니다:
      - 원격 브랜치: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 로컬 브랜치: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Specs 디렉터리: `specs/[0-9]+-<short-name>`와 일치하는 디렉터리 확인

   c. 다음 사용 가능한 번호 결정:
      - 모든 세 소스에서 모든 번호 추출
      - 가장 높은 번호 N 찾기
      - 새 브랜치 번호에 N+1 사용

   d. 계산된 번호와 short-name으로 스크립트 `{SCRIPT}` 실행:
      - 기능 설명과 함께 `--number N+1` 및 `--short-name "your-short-name"` 전달
      - Bash 예시: `{SCRIPT} --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 예시: `{SCRIPT} -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **중요**:
   - 가장 높은 번호를 찾기 위해 세 가지 소스(원격 브랜치, 로컬 브랜치, specs 디렉터리) 모두 확인
   - 정확한 short-name 패턴과 일치하는 브랜치/디렉터리만 매치
   - 이 short-name으로 기존 브랜치/디렉터리를 찾을 수 없으면 번호 1로 시작
   - 기능당 이 스크립트를 한 번만 실행해야 합니다
   - JSON은 터미널에 출력으로 제공됩니다 - 찾고 있는 실제 콘텐츠를 얻기 위해 항상 이를 참조하세요
   - JSON 출력에는 BRANCH_NAME 및 SPEC_FILE 경로가 포함됩니다
   - "I'm Groot"와 같이 인수에 작은따옴표가 있는 경우 이스케이프 구문 사용: 예: 'I'\''m Groot' (또는 가능한 경우 큰따옴표: "I'm Groot")

3. 필수 섹션을 이해하기 위해 `templates/spec-template.md`를 로드합니다.

4. 다음 실행 흐름을 따르세요:

    1. 입력에서 사용자 설명 파싱
       비어 있는 경우: ERROR "기능 설명이 제공되지 않음"
    2. 설명에서 핵심 개념 추출
       식별: 액터, 액션, 데이터, 제약사항
    3. 불명확한 측면의 경우:
       - 컨텍스트 및 업계 표준을 기반으로 정보에 입각한 추측
       - 다음의 경우에만 [명확화 필요: 특정 질문]으로 표시:
         - 선택이 기능 범위 또는 사용자 경험에 크게 영향을 미침
         - 서로 다른 의미를 갖는 여러 합리적인 해석이 존재
         - 합리적인 기본값이 없음
       - **제한: 최대 3개의 [명확화 필요] 마커**
       - 영향별 명확화 우선순위: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
    4. 사용자 시나리오 및 테스트 섹션 채우기
       명확한 사용자 흐름이 없는 경우: ERROR "사용자 시나리오를 결정할 수 없음"
    5. 기능 요구사항 생성
       각 요구사항은 테스트 가능해야 함
       지정되지 않은 세부사항에 합리적인 기본값 사용 (가정 섹션에 가정 문서화)
    6. 성공 기준 정의
       측정 가능하고 기술 독립적인 결과 생성
       정량적 메트릭 (시간, 성능, 볼륨) 및 정성적 측정 (사용자 만족도, 작업 완료) 모두 포함
       각 기준은 구현 세부사항 없이 확인 가능해야 함
    7. 주요 엔티티 식별 (데이터가 관련된 경우)
    8. 반환: SUCCESS (계획 준비 완료된 명세)

5. 템플릿 구조를 사용하여 SPEC_FILE에 명세를 작성하고, 섹션 순서 및 제목을 유지하면서 기능 설명(인수)에서 도출된 구체적인 세부사항으로 플레이스홀더를 교체합니다.

6. **명세 품질 검증**: 초기 명세를 작성한 후 품질 기준에 대해 검증합니다:

   a. **명세 품질 체크리스트 생성**: 다음 검증 항목이 포함된 체크리스트 템플릿 구조를 사용하여 `FEATURE_DIR/checklists/requirements.md`에 체크리스트 파일을 생성합니다:

      ```markdown
      # 명세 품질 체크리스트: [기능명]

      **목적**: 계획으로 진행하기 전에 명세 완전성 및 품질 검증
      **생성일**: [날짜]
      **기능**: [spec.md로의 링크]

      ## 콘텐츠 품질

      - [ ] 구현 세부사항 없음 (언어, 프레임워크, API)
      - [ ] 사용자 가치 및 비즈니스 요구사항에 초점
      - [ ] 비기술 이해관계자를 위해 작성됨
      - [ ] 모든 필수 섹션 완료

      ## 요구사항 완전성

      - [ ] [명확화 필요] 마커가 남아있지 않음
      - [ ] 요구사항이 테스트 가능하고 명확함
      - [ ] 성공 기준이 측정 가능함
      - [ ] 성공 기준이 기술 독립적임 (구현 세부사항 없음)
      - [ ] 모든 수락 시나리오가 정의됨
      - [ ] 엣지 케이스가 식별됨
      - [ ] 범위가 명확하게 경계 지어짐
      - [ ] 의존성 및 가정이 식별됨

      ## 기능 준비 상태

      - [ ] 모든 기능 요구사항에 명확한 수락 기준이 있음
      - [ ] 사용자 시나리오가 주요 흐름을 다룸
      - [ ] 기능이 성공 기준에 정의된 측정 가능한 결과를 충족함
      - [ ] 명세에 구현 세부사항이 누출되지 않음

      ## 참고사항

      - 미완료로 표시된 항목은 `/speckit.clarify` 또는 `/speckit.plan` 전에 명세 업데이트가 필요함
      ```

   b. **검증 확인 실행**: 각 체크리스트 항목에 대해 명세를 검토합니다:
      - 각 항목에 대해 통과 또는 실패 여부를 결정합니다
      - 발견된 특정 문제를 문서화합니다 (관련 명세 섹션 인용)

   c. **검증 결과 처리**:

      - **모든 항목이 통과하는 경우**: 체크리스트를 완료로 표시하고 6단계로 진행합니다

      - **항목이 실패하는 경우 ([명확화 필요] 제외)**:
        1. 실패한 항목과 특정 문제를 나열합니다
        2. 각 문제를 해결하기 위해 명세를 업데이트합니다
        3. 모든 항목이 통과할 때까지 검증을 재실행합니다 (최대 3회 반복)
        4. 3회 반복 후에도 여전히 실패하는 경우 체크리스트 참고사항에 남은 문제를 문서화하고 사용자에게 경고합니다

      - **[명확화 필요] 마커가 남아있는 경우**:
        1. 명세에서 모든 [명확화 필요: ...] 마커를 추출합니다
        2. **제한 확인**: 3개 이상의 마커가 존재하는 경우 가장 중요한 3개만 유지하고 (범위/보안/UX 영향 기준) 나머지는 정보에 입각한 추측을 합니다
        3. 명확화가 필요한 각 항목(최대 3개)에 대해 다음 형식으로 사용자에게 옵션을 제시합니다:

           ```markdown
           ## 질문 [N]: [주제]

           **컨텍스트**: [관련 명세 섹션 인용]

           **알아야 할 사항**: [명확화 필요 마커의 구체적인 질문]

           **제안된 답변**:

           | 옵션 | 답변 | 영향 |
           |--------|--------|--------------|
           | A      | [첫 번째 제안 답변] | [기능에 미치는 의미] |
           | B      | [두 번째 제안 답변] | [기능에 미치는 의미] |
           | C      | [세 번째 제안 답변] | [기능에 미치는 의미] |
           | 커스텀 | 직접 답변 제공 | [커스텀 입력 제공 방법 설명] |

           **선택**: _[사용자 응답 대기]_
           ```

        4. **중요 - 테이블 형식**: 마크다운 테이블이 올바르게 형식화되었는지 확인합니다:
           - 파이프가 정렬된 일관된 간격 사용
           - 각 셀은 콘텐츠 주위에 공백이 있어야 함: `| 콘텐츠 |` 형식, `|콘텐츠|` 아님
           - 헤더 구분자는 최소 3개의 대시가 있어야 함: `|--------|`
           - 마크다운 미리보기에서 테이블이 올바르게 렌더링되는지 테스트
        5. 질문을 순차적으로 번호 매김 (Q1, Q2, Q3 - 최대 3개)
        6. 응답을 기다리기 전에 모든 질문을 함께 제시
        7. 사용자가 모든 질문에 대한 선택으로 응답할 때까지 대기 (예: "Q1: A, Q2: 커스텀 - [세부사항], Q3: B")
        8. 각 [명확화 필요] 마커를 사용자가 선택하거나 제공한 답변으로 교체하여 명세를 업데이트
        9. 모든 명확화가 해결된 후 검증을 재실행

   d. **체크리스트 업데이트**: 각 검증 반복 후 현재 통과/실패 상태로 체크리스트 파일을 업데이트합니다

7. 브랜치 이름, 명세 파일 경로, 체크리스트 결과 및 다음 단계 준비 상태(`/speckit.clarify` 또는 `/speckit.plan`)와 함께 완료를 보고합니다.

**참고:** 스크립트는 새 브랜치를 생성하고 체크아웃하며 작성하기 전에 명세 파일을 초기화합니다.

## 일반 가이드라인

## 빠른 가이드라인

- 사용자가 **무엇**을 필요로 하고 **왜** 필요한지에 초점을 맞춥니다.
- 구현 방법 피하기 (기술 스택, API, 코드 구조 없음).
- 개발자가 아닌 비즈니스 이해관계자를 위해 작성됩니다.
- 명세에 포함된 체크리스트를 생성하지 마십시오. 그것은 별도의 명령입니다.

### 섹션 요구사항

- **필수 섹션**: 모든 기능에 대해 완료되어야 함
- **선택적 섹션**: 기능과 관련된 경우에만 포함
- 섹션이 적용되지 않으면 완전히 제거 ("N/A"로 남기지 않음)

### AI 생성을 위한 지침

사용자 프롬프트에서 이 명세를 생성할 때:

1. **정보에 입각한 추측**: 컨텍스트, 업계 표준 및 일반 패턴을 사용하여 갭 채우기
2. **가정 문서화**: 가정 섹션에 합리적인 기본값 기록
3. **명확화 제한**: 최대 3개의 [명확화 필요] 마커 - 다음과 같은 중요한 결정에만 사용:
   - 기능 범위 또는 사용자 경험에 크게 영향을 미침
   - 서로 다른 의미를 갖는 여러 합리적인 해석이 있음
   - 합리적인 기본값이 없음
4. **명확화 우선순위 지정**: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
5. **테스터처럼 생각**: 모든 모호한 요구사항은 "테스트 가능하고 명확한" 체크리스트 항목을 통과하지 못해야 함
6. **명확화가 필요한 일반적인 영역** (합리적인 기본값이 없는 경우에만):
   - 기능 범위 및 경계 (특정 사용 사례 포함/제외)
   - 사용자 유형 및 권한 (여러 충돌하는 해석이 가능한 경우)
   - 보안/규정 준수 요구사항 (법적/재정적으로 중요한 경우)

**합리적인 기본값의 예시** (이것들에 대해 질문하지 마세요):

- 데이터 보존: 도메인에 대한 업계 표준 관행
- 성능 목표: 지정되지 않은 한 표준 웹/모바일 앱 기대치
- 오류 처리: 적절한 폴백이 있는 사용자 친화적인 메시지
- 인증 방법: 웹 앱의 경우 표준 세션 기반 또는 OAuth2
- 통합 패턴: 달리 지정되지 않는 한 RESTful API

### 성공 기준 가이드라인

성공 기준은 다음이어야 합니다:

1. **측정 가능**: 특정 메트릭 포함 (시간, 백분율, 개수, 비율)
2. **기술 독립적**: 프레임워크, 언어, 데이터베이스 또는 도구 언급 없음
3. **사용자 중심**: 시스템 내부가 아닌 사용자/비즈니스 관점에서 결과 설명
4. **확인 가능**: 구현 세부사항을 모르고도 테스트/검증 가능

**좋은 예시**:

- "사용자가 3분 이내에 체크아웃을 완료할 수 있음"
- "시스템이 10,000명의 동시 사용자를 지원"
- "검색의 95%가 1초 이내에 결과를 반환"
- "작업 완료율이 40% 향상"

**나쁜 예시** (구현 중심):

- "API 응답 시간이 200ms 이내" (너무 기술적, "사용자가 즉시 결과를 봄" 사용)
- "데이터베이스가 1000 TPS를 처리할 수 있음" (구현 세부사항, 사용자 대면 메트릭 사용)
- "React 컴포넌트가 효율적으로 렌더링" (프레임워크별)
- "Redis 캐시 히트율이 80% 이상" (기술별)
